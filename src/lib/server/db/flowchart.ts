import { Prisma } from '@prisma/client';
import { prisma } from '$lib/server/db/prisma';
import { initLogger } from '$lib/common/config/loggerConfig';
import {
  convertDBFlowchartToFlowchart,
  convertFlowchartToDBFlowchart
} from '$lib/server/util/flowDataUtil';
import type { MutateFlowchartData } from '$lib/types';

const logger = initLogger('DB/Flowchart');

// TODO: add tests for this?
export async function getUserFlowcharts(
  userId: string,
  ids: string[] = []
): Promise<MutateFlowchartData[]> {
  const res = await prisma.dBFlowchart.findMany({
    where: {
      ownerId: userId,
      ...(ids.length && {
        id: {
          in: ids
        }
      })
    },
    orderBy: {
      pos: 'asc'
    }
  });

  const resConverted = res.map((flow) => convertDBFlowchartToFlowchart(flow));

  logger.info('Fetched flowcharts for user', userId);

  return resConverted;
}

// TODO: pass in chunk list so we can compute which properties are changed (or do this in mutateUserDataUtilServer)
export async function upsertFlowcharts(flowcharts: MutateFlowchartData[]): Promise<void> {
  // prepare data for interactive transaction
  const flowTransactionQueryPieces = flowcharts.map((flowchartData) => {
    const { id, ...dbFlow } = convertFlowchartToDBFlowchart(flowchartData);
    return {
      id,
      dbFlow
    };
  });

  // perform interactive transaction to update relevant flowcharts
  await prisma.$transaction(async (tx) => {
    for await (const { id, dbFlow } of flowTransactionQueryPieces) {
      // termData should never be falsy, always array-type and at minimum []
      if (!dbFlow.termData) {
        throw new Error('Flowchart termData should never be null');
      }

      // notes:
      // 1. lastUpdatedUTC time should be updated in mutateUserDataUtilCommon
      //    so that update times stay in sync between client and server
      // 2. termData will never be null, but doing optional chaining to satisfy types
      // 3. validationData CAN be null, though, so make sure we use DbNull here in that case

      // TODO: update only modified properties instead of blanket all
      // see https://github.com/prisma/prisma/issues/9247#issuecomment-1249322729

      const upsertData = {
        ...dbFlow,
        termData: dbFlow.termData ?? Prisma.DbNull,
        validationData: dbFlow.validationData ?? Prisma.DbNull
      };

      await tx.dBFlowchart.upsert({
        where: {
          id
        },
        create: {
          // don't let flow id be autogenerated since it's already defined in input payload
          id,
          ...upsertData
        },
        update: upsertData
      });
    }
  });

  logger.info(
    `Successfully persisted updates for flowcharts [${flowTransactionQueryPieces.map(
      (queryPiece) => queryPiece.id
    )}]`
  );
}

export async function deleteFlowcharts(ids: string[]): Promise<void> {
  await prisma.dBFlowchart.deleteMany({
    where: {
      id: {
        in: ids
      }
    }
  });

  logger.info(`Successfully deleted flowcharts [${ids}]`);
}
